function [tbl, tbl_orig] = VPmonkey_import_electrodeDepths %(workbookFile, sheetName, dataLines)
%IMPORTFILE Import data from a spreadsheet
%  SUAPROTOCOL = IMPORTFILE(FILE) reads data from the first worksheet in
%  the Microsoft Excel spreadsheet file named FILE.  Returns the data as
%  a table.
%
%  SUAPROTOCOL = IMPORTFILE(FILE, SHEET) reads from the specified
%  worksheet.
%
%  SUAPROTOCOL = IMPORTFILE(FILE, SHEET, DATALINES) reads from the
%  specified worksheet for the specified row interval(s). Specify
%  DATALINES as a positive scalar integer or a N-by-2 array of positive
%  scalar integers for dis-contiguous row intervals.
%
%  Example:
%  SUAprotocol = importfile("/home/rick/neuro/iannettilab/Projects/VP monkey/SUA_protocol.xlsx", "Foglio1", [1, 32]);
%
%  See also READTABLE.
%
% Auto-generated by MATLAB on 08-Jul-2022 14:00:46

%% Input handling

workbookFile = [getRoot '/VPmonkey/SUA_protocol.xlsx'];

% % If no sheet is specified, read first sheet
% if nargin == 1 || isempty(sheetName)
    sheetName = 1;
% end
% 
% % If row start and end points are not specified, define defaults
% if nargin <= 2
    dataLines = [1, 32];
% end

%% Set up the Import Options and import the data
opts = spreadsheetImportOptions("NumVariables", 42);

% Specify sheet and range
opts.Sheet = sheetName;
opts.DataRange = "A" + dataLines(1, 1) + ":AP" + dataLines(1, 2);

% Specify column names and types
opts.VariableNames = ["sesh", "Dura_T1", "Dura_T2", "Dura_T3", "Dura_T4", "Dura_T5", "Dura_M1", "Dura_M2", "Dura_M3", "Dura_M4", "Dura_M5", "TOA_T1", "TOA_T2", "TOA_T3", "TOA_T4", "TOA_T5", "TOA_M1", "TOA_M2", "TOA_M3", "TOA_M4", "TOA_M5", "Depth_T1", "Depth_T2", "Depth_T3", "Depth_T4", "Depth_T5", "Depth_M1", "Depth_M2", "Depth_M3", "Depth_M4", "Depth_M5", "matT_dist", "matT_angle", "matM_dist", "matM_angle", "Var36", "Var37", "Var38", "Var39", "Var40", "Var41", "RecordingDay"];
opts.SelectedVariableNames = ["sesh", "Dura_T1", "Dura_T2", "Dura_T3", "Dura_T4", "Dura_T5", "Dura_M1", "Dura_M2", "Dura_M3", "Dura_M4", "Dura_M5", "TOA_T1", "TOA_T2", "TOA_T3", "TOA_T4", "TOA_T5", "TOA_M1", "TOA_M2", "TOA_M3", "TOA_M4", "TOA_M5", "Depth_T1", "Depth_T2", "Depth_T3", "Depth_T4", "Depth_T5", "Depth_M1", "Depth_M2", "Depth_M3", "Depth_M4", "Depth_M5", "matT_dist", "matT_angle", "matM_dist", "matM_angle", "RecordingDay"];
opts.VariableTypes = ["char", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "categorical", "double", "categorical", "double", "char", "char", "char", "char", "char", "char", "double"];

% Specify variable properties
opts = setvaropts(opts, ["sesh", "Var36", "Var37", "Var38", "Var39", "Var40", "Var41"], "WhitespaceRule", "preserve");
opts = setvaropts(opts, ["sesh", "matT_dist", "matM_dist", "Var36", "Var37", "Var38", "Var39", "Var40", "Var41"], "EmptyFieldRule", "auto");

% Import the data
SUAprotocol = readtable(workbookFile, opts, "UseExcel", false);

for idx = 2:size(dataLines, 1)
    opts.DataRange = "A" + dataLines(idx, 1) + ":AP" + dataLines(idx, 2);
    tb = readtable(workbookFile, opts, "UseExcel", false);
    SUAprotocol = [SUAprotocol; tb]; %#ok<AGROW>
end

%% reformat nicely
SUAprotocol = SUAprotocol(4:end,:);
for k = 1:size(SUAprotocol,1)
    temp = strsplit(SUAprotocol.sesh{k},'_');
    if length(temp{1})==4
        SUAprotocol.sesh{k} = temp{1}([1,3,4]);
    else
        SUAprotocol.sesh{k} = temp{1};
    end
end

%% compute depths relative to TOA and Dura
subs = {'T','M'};
for sb = 1:length(subs)
    sub = subs{sb};
    for k = 1:5

        % compute depths relative to landmarks
        Dura  = SUAprotocol.(['Dura_' sub num2str(k)]);
        TOA   = SUAprotocol.(['TOA_'  sub num2str(k)]);
        depth = SUAprotocol.(['Depth_'  sub num2str(k)]);
        %
        DepthRelTOA     = depth - TOA;
        DepthRelDura    = depth - Dura;
        %
        SUAprotocol.(['DepthRelTOA_'  sub num2str(k) ]) = DepthRelTOA;
        SUAprotocol.(['DepthRelDura_' sub num2str(k) ]) = DepthRelDura;

    end
end

%% reorder table to stack channels
tbl_orig = SUAprotocol;


%! do as struct then conver to table
%! do once per subj and stack them

tbl = [];
subs = ['M','T'];
for sub = subs
    for r = 1:size(tbl_orig)

        temp = struct;
        temp.sub  = sub;
        temp.sesh = tbl_orig.sesh{r};
        temp.dist  = sprintf('%s', tbl_orig.(['mat' sub '_dist'])(r) );
        temp.angle = tbl_orig.(['mat' sub '_angle'])(r);
        temp.recordingday = tbl_orig.RecordingDay(r);
        temp = repmat(temp,5,1);
        % get depths
        for k = 1:5
            temp(k).elec = k;
            temp(k).Depth = tbl_orig.(['Depth_' sub num2str(k)])(r);
            temp(k).Dura  = tbl_orig.(['Dura_' sub num2str(k)])(r);
            temp(k).TOA   = tbl_orig.(['TOA_' sub num2str(k)])(r);
            temp(k).DepthRelDura   = tbl_orig.(['DepthRelDura_' sub num2str(k)])(r);
            temp(k).DepthRelTOA   = tbl_orig.(['DepthRelTOA_' sub num2str(k)])(r);
        end

        tbl = [tbl; temp];

    end % session loop
end % sub loop
tbl = struct2table(tbl);

% add simple label for electrode locations from pairs of dist and angle
tbl.dist_angle = cellfun( @(a,b) [a '_' b], ...
        tbl.dist, strsplit(num2str(tbl.angle'))', ...
        'uniformoutput',false );

%% convert dist and angle coordinates into X and Y
% ? NOTE I need to check these with Eros
[~,~,dists] = unique(tbl.dist);
dists(dists==5) = nan;
theta = tbl.angle;
for k = 1:size(tbl,1)

    tbl.x(k) = dists(k) * sind(theta(k));
    tbl.y(k) = dists(k) * cosd(theta(k));

end



